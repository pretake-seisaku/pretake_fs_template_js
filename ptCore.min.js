import "core-js/stable";
import "regenerator-runtime/runtime";
import smoothscroll from 'smoothscroll-polyfill';
import {bodyScrollPreventSimple} from './module/_mod_bodyScrollPrevent';
import {dropdown} from './module/_mod_dropdown';
import {tglPanel} from './module/_mod_togglePanel';
import objectFitImages from 'object-fit-images';

//参考: https://notes.sharesl.net/articles/1601/#%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6%e5%af%be%e5%bf%9c%e7%8a%b6%e6%b3%81
// const imagesLoaded = require('imagesloaded');
require('intersection-observer');
smoothscroll.polyfill();

//- パネル切り替え
//- =========================================================

if (typeof (window.pretakeProtoStinckyFix) == "undefined") {

  //constructor
  const evFuncStinckyFix = function (tar, tarWrap) {
    this.tar = tar;
    this.tarWrap = tarWrap;
    this.arr = this.__arr.bind(this);
    this.observe = function () {};
    this.currRelative = 0;
    this.watchScroll = this.__funcScroll.bind(this);
    this.obBool = false;
  }
  //methods
  evFuncStinckyFix.prototype = {
    evScroll: function () {
      const __this = this;
      window.document.addEventListener('scroll', __this.watchScroll, false);
    },
    evScrollRemove: function () {
      const __this = this;
      window.document.removeEventListener('scroll', __this.watchScroll, false);
    },
    obWatch: function (isOpen) {
      const __this = this;
      const tarbody = __this.arr();
      const datasetTar = tarbody.hbody;
      this.observe = evFuncStinckyFix.prototype.__funcObserver(__this, tarbody.stickyElm, isOpen);
      this.observe.observe(datasetTar, {
        attributes: true,
        attributeFilter: ['class']
      });
      this.obBool = true;
    },
    obDestroy: function () {
      if (this.obBool === true) {
        const __this = this;
        const arr = __this.arr();
        const stickyElm = arr.stickyElm;
        stickyElm.style.position = '';
        stickyElm.style.top = '';
        stickyElm.style.transition = '';

        this.observe.disconnect();
      }
    },
    __arr: function () {
      const __const = this;
      const data = {
        stickyElm: document.querySelector(__const.tar),
        stickyElmWrap: document.querySelector(__const.tarWrap),
        hbody: document.getElementsByTagName('body')[0],
      };
      return data;
    },
    __getPosition: function (stickyElm, stickyElmWrap) {
      const relativePositionTop = stickyElm.getBoundingClientRect().top;
      const absolutePositionTop = stickyElmWrap.getBoundingClientRect().top + window.pageYOffset;
      const doch = window.pageYOffset || document.documentElement.scrollTop; //トップからの現在位置を表示
      const result = relativePositionTop + doch - absolutePositionTop;

      return result;
    },
    __funcObserver: function (__constructor, __arr, checkClass) {
      const __const = __constructor;
      const arr = __const.arr();
      const stickyElm = arr.stickyElm;
      const stickyElmWrap = arr.stickyElmWrap;
      const cheker = (typeof checkClass == 'string') ? true:false;
      let observer;

      if (cheker) {
        observer = new MutationObserver(records => {
          const currTar = records[0].target;
          
          if (!currTar.classList.contains(checkClass)) {
            stickyElm.style.position = 'sticky';
            stickyElm.style.top = '';
            const resultDire = evFuncStinckyFix.prototype.__getPosition(stickyElm, stickyElmWrap);
            __const.currRelative = resultDire;
            stickyElm.style.transition = '';
          } else {
            stickyElm.style.position = 'relative';
            stickyElm.style.top = __const.currRelative + 'px';
            stickyElm.style.transition = 0 + 's';
          }
  
        })
      } else {
        observer = new MutationObserver(records => {
          const currTar = records[0].target;
          const func = ()=>{
            let checkBool;
            for (let i = 0; i < checkClass.length; i++) {
              const bool = currTar.classList.contains(checkClass[i]);
              if (bool === true){
                return checkBool = false;
              }
            }
            return checkBool = true;
          };
          if (func()) {
            stickyElm.style.position = 'sticky';
            stickyElm.style.top = '';
            const resultDire = evFuncStinckyFix.prototype.__getPosition(stickyElm, stickyElmWrap);
            __const.currRelative = resultDire;
            stickyElm.style.transition = '';
          } else {
            stickyElm.style.position = 'relative';
            stickyElm.style.top = __const.currRelative + 'px';
            stickyElm.style.transition = 0 + 's';
          }
  
        })
      }
      return observer;
    },
    
    __funcScroll: function (e) {
      const __this = this;
      const tarbody = __this.arr();
      const stickyElm = tarbody.stickyElm;
      const stickyElmWrap = tarbody.stickyElmWrap;
      const resultDire = evFuncStinckyFix.prototype.__getPosition(stickyElm, stickyElmWrap);
      if (resultDire > 0) {
        this.currRelative = resultDire;
      }
    }
  };
  window.pretakeProtoStinckyFix = evFuncStinckyFix;
}

if (typeof (window.pretakeProtoModal) == "undefined") {
  //constructor
  const pretakeProtoModal = function (set,timeout=400) {
    this.cWrap = set.wrap;
    this.cOpen = set.open;
    this.cClosed = set.closed;
    this.cClosedBgElm = set.closedBgElm;
    this.activeCls = set.activeCls;
    this.aniCls = set.aniCls;
    this.isActiveB = set.isActiveB;
    this.arrCore = this.__arrCore;
    this.timeout = timeout;
    this.openL = this.__openLisner.bind(this);
    this.closedL = this.__closedLisner.bind(this);
    this.closedLC = this.__closedLisnerCurrent.bind(this);
  }
  //methods
  pretakeProtoModal.prototype = {
    setModal: function (setNum='.__mdl1') {
      const __this = this;
      const arrCntOpen = document.querySelectorAll(__this.cOpen + setNum);
      const arrCntClosed = document.querySelectorAll(__this.cClosed + setNum);
      const arrCntBg = document.querySelectorAll(__this.cWrap + setNum);
      arrCntOpen.forEach(elm => {
        elm.addEventListener('click', this.openL);
      });
      arrCntClosed.forEach(elm => {
        elm.addEventListener('click', this.closedL);
      });
      arrCntBg.forEach(elm => {
        elm.addEventListener('click', this.closedLC);
      });
    },
    
    removeModal: function (setNum='.__mdl1') {
      const __this = this;
      const arrCntOpen = document.querySelectorAll(__this.cOpen + setNum);
      const arrCntClosed = document.querySelectorAll(__this.cClosed + setNum);
      const arrCntBg = document.querySelectorAll(__this.cWrap + setNum);
      arrCntOpen.forEach(elm => {
        elm.removeEventListener('click', this.openL);
      });
      arrCntClosed.forEach(elm => {
        elm.removeEventListener('click', this.closedL);
      });
      arrCntBg.forEach(elm => {
        elm.removeEventListener('click', this.closedLC);
      });
    },
    __openLisner: function (e) {
      const __this = this;
      e.preventDefault();
      e.stopPropagation();
      const arrCnt = document.querySelector(__this.cWrap);
      pretakeProtoModal.prototype.__openFunc(__this,arrCnt);
    },
    __closedLisner: function (e) {
      const __this = this;
      e.preventDefault();
      e.stopPropagation();
      const arrCnt = document.querySelector(__this.cWrap);
      pretakeProtoModal.prototype.__closedFunc(__this,arrCnt);
    },
    __closedLisnerCurrent: function (e) {
      const __this = this;
      const arrCnt = e.target;
      if (arrCnt.classList.contains(__this.cClosedBgElm)) {
        e.preventDefault();
        e.stopPropagation();
        pretakeProtoModal.prototype.__closedFunc(__this,arrCnt);
      }
    },
    __openFunc: function (__constructor,arr) {
      const __this = __constructor;
      bodyScrollPreventSimple(true);
      
      async function aPromise() {
        arr.classList.add(__this.activeCls);
      }
      async function bPromise() {
        await aPromise().then(value => {
          arr.classList.add(__this.aniCls);
        });
      }
      bPromise();
    },
    __closedFunc: function (__constructor,arr) {
      const __this = __constructor;
      bodyScrollPreventSimple(false);
      
      async function aPromise() {
        arr.classList.remove(__this.aniCls);
      }
      async function bPromise() {
        await aPromise().then(value => {
          setTimeout(() => {
            arr.classList.remove(__this.activeCls);
          }, __this.timeout);
        });
      }
      bPromise();
    }
    
  };

  window.pretakeProtoModal = pretakeProtoModal;
}

if (typeof (window.pretakeScript) == "undefined") {

  //constructor
  const pretakeScript = function () {}

  //methods
  pretakeScript.prototype = {
    //bodyのクラス判別
    bodyClsContains: function (cls) {
      const bodyCls = document.body.getAttribute('class').split(' ');
      const contains = bodyCls.indexOf(cls) > -1;
      return contains;
    },
    //アンカーのID利用のスムーズスクロール
    smoothScroll: function (ID = "top-glnav", except = []) {

      const smoothScrollTrigger = document.querySelectorAll('a[href^="#"]');

      function clickFunc(e) {
        e.preventDefault();
        const targetElement = this.arr;
        const rect = targetElement.getBoundingClientRect().top; // ブラウザからの高さを取得
        const offset = window.pageYOffset; // 現在のスクロール量を取得
        const gap = document.getElementById(ID).offsetHeight;
        const target = rect + offset - gap;
        window.scrollTo({
          top: target,
          behavior: 'smooth',
        });
      };
      for (let i = 0; i < smoothScrollTrigger.length; i++) {
        const href = smoothScrollTrigger[i].getAttribute('href');
        const ehref = href.replace('#', '');
        const targetElement = document.getElementById(ehref);

        if (except.length === 0) {
          const arrCnt = targetElement;
          smoothScrollTrigger[i].addEventListener('click', {
            arr: arrCnt,
            handleEvent: clickFunc
          });
        } else {
          for (let y = 0; y < except.length; y++) {
            const elm = except[y];
            if (elm === ehref) {
              const arrCnt = '';
            } else {
              const arrCnt = targetElement;
              smoothScrollTrigger[i].addEventListener('click', {
                arr: arrCnt,
                handleEvent: clickFunc
              });
            }
          }
        };

      }
    },
    //ページ移動時、アンカーのIDの位置まで移動。（top-glnav分ずらす）
    locationMoveToTag: function (ID = "top-glnav") {
      const hash = location.hash;
      if (hash) {
        const gap = document.getElementById(ID).offsetHeight;
        const offset = window.pageYOffset;
        const target = offset - gap;
        setTimeout(() => {
          window.scrollTo({
            top: target,
          });
        }, 1);
      }
    },
    inView: function (cls, op, anotherCls = null, addCls = 'is-active', onlyOnce = false) {

      let observerBefore = {};
      let observerAfter = {};
      let swTarget = {};

      const target = document.querySelectorAll(cls)
      const targetArray = Array.prototype.slice.call(target);
      const addClsName = addCls;

      if (anotherCls !== null) {
        swTarget = document.querySelector(anotherCls);
      }

      const options = () => {
        if (typeof op.after !== 'undefined') {
          const options = {
            before: {
              root: op.before.root,
              rootMargin: op.before.rootMargin,
              threshold: op.before.threshold
            },
            after: {
              root: op.after.root,
              rootMargin: op.after.rootMargin,
              threshold: op.after.threshold
            }
          };
          return options;
        } else {
          const options = {
            before: {
              root: op.before.root,
              rootMargin: op.before.rootMargin,
              threshold: op.before.threshold
            }
          };
          return options;
        };
      }

      if (anotherCls !== null) {
        observerBefore = new IntersectionObserver(callbackBefore, options().before)
        observerAfter = new IntersectionObserver(callbackAfter, options().after)
      } else if (anotherCls === null) {
        observerBefore = new IntersectionObserver(callbackBeforeMulti, options().before)
        observerAfter = new IntersectionObserver(callbackAfterMulti, options().after)
      }

      targetArray.forEach((tgt) => {

        if (onlyOnce || typeof op.after === 'undefined') {
          observerBefore.observe(tgt)
        } else {
          observerBefore.observe(tgt)
          observerAfter.observe(tgt)
        }

      });

      function callbackBefore(entries) {
        entries.forEach(function (entry, i) {
          const target = entry.target;
          if (entry.isIntersecting && !swTarget.classList.contains(addClsName)) {

            swTarget.classList.add(addClsName);

          }
        });
      };

      function callbackAfter(entries) {
        entries.forEach(function (entry, i) {
          const target = entry.target;
          if (!entry.isIntersecting && swTarget.classList.contains(addClsName)) {

            swTarget.classList.remove(addClsName);

          }
        });
      };


      function callbackBeforeMulti(entries) {
        entries.forEach(function (entry, i) {
          const multiTarget = entry.target;
          if (entry.isIntersecting && !multiTarget.classList.contains(addClsName)) {

            multiTarget.classList.add(addClsName);

          }
        });
      }

      function callbackAfterMulti(entries) {
        entries.forEach(function (entry, i) {
          const multiTarget = entry.target;
          if (!entry.isIntersecting && multiTarget.classList.contains(addClsName)) {

            multiTarget.classList.remove(addClsName);

          }
        });
      }
    },
    scrollOffsetSwitch: function (e, ID, offset, isCls = 'is-enabled', bodyActive = 'active-style',disapearAtFooter = false) {
      const wrapID = window.document.querySelector(ID);
      const isBodyCls = pretakeScript.prototype.bodyClsContains(bodyActive);
      const doch = window.pageYOffset || document.documentElement.scrollTop; //トップからの現在位置を表示
      if (disapearAtFooter === false) {
        if (doch > offset) {
          wrapID.classList.add(isCls);
        } else if (isBodyCls == false && doch < offset) {
          wrapID.classList.remove(isCls);
        }
      } else {
        const relativePositionBottom = document.querySelector(footerCls).getBoundingClientRect().top - window.innerHeight;

        if (doch > offset && relativePositionBottom > 0) {
            wrapID.classList.add(isCls);
        } else if(document.body.classList.contains(bodyActive) == false && doch < offset) {
            wrapID.classList.remove(isCls);
        } else if(relativePositionBottom < 0) {
            wrapID.classList.remove(isCls);
        }
      }

    },
    bodyScrollPrevent: bodyScrollPreventSimple,

    switchEvent: function(bp = 800, func) {
      const breakPoint = bp;
      let resizeBool;
      window.addEventListener('load', () => {
        if (breakPoint < window.innerWidth) {
          func.mqMin();
          resizeBool = false;
        } else {
          func.mqMax();
          resizeBool = true;
        }
      }, false);
      window.addEventListener('resize', () => {
        if (breakPoint < window.innerWidth && resizeBool) {
          func.mqMin();
          resizeBool = false;
        } else if (breakPoint >= window.innerWidth && !(resizeBool)) {
          func.mqMax();
          resizeBool = true;
        }
      }, false);
    },
    dropdown:dropdown,
    tglPanel:tglPanel,
    addClsFsMenu:function (cls) {
      const tarMenu = document.querySelector(cls);
      const array = Array.prototype.slice.call(tarMenu.querySelectorAll('.fs-pt-menu__heading'));
      array.forEach(elm => {
        const fragment = document.createDocumentFragment();
        const item = document.createElement('span');
        item.className = 'fs-pt-menu__h-open'; 
        fragment.appendChild(item);
        const nextElm = (elm.nextElementSibling === null) ? null:elm.nextElementSibling;
        const parentElm = (elm.parentNode === null) ? null:elm.parentNode;
        if (nextElm) {
          elm.classList.add('pt-existed-next');
          nextElm.classList.add('__acc-items')
          parentElm.classList.add('__acc-wrap');
          elm.appendChild(fragment);
        }
      });
    },
    bannerPopUp:function(cnt={}){
      const PROD_DOMAIN = location.hostname;
      const ckValue = "ymCookieBannerAppearing";
      const ckData = 'hidden';
      const addClass = (cnt.addClass === undefined) ? 'is-enabled':cnt.addClass; 
      const bodyActive = (cnt.bodyActive === undefined) ? 'active-style':cnt.bodyActive;
      const ymBannerID = (cnt.bannerID === undefined) ? '#pt-banner-contents':cnt.bannerID;
      const footerCls =  (cnt.footerClass === undefined) ? '.footer-sec__body':cnt.footerClass;
      const offsetTop = (cnt.offsetTop === undefined) ? 300:cnt.offsetTop;
      const maxAge = (cnt.maxAge === undefined) ? 600:cnt.maxAge;
      const disapearAtFooter = (cnt.disapearAtFooter === undefined) ? false:cnt.disapearAtFooter;
      const wrapID = window.document.querySelector(ymBannerID);
      const closedBtn = document.querySelector('.fixed-banner__closed-btn');
      const ckGetValueFromStrage = ckGet(ckValue);
    
      function ckGet(keyName) {
        var cookies = document.cookie;
        var cookiesArray = cookies.split(';');
      
        for(var c of cookiesArray){
          var cArray = c.split('=');
          if( cArray[0].trim(" ") == keyName){
              return decodeURIComponent(cArray[1]);
          }
        }
        return undefined;
    
      }
      function ckSet(keyName,keyValue,domain) {
        var ckValueName = keyName;
        var ckValueNamePlus = ckValueName + "=";
        var prodDomain = ";domain=" + domain;
        var check = ckGet(ckValueName);
        if (!check) {
          document.cookie = ckValueNamePlus + encodeURIComponent(keyValue) + ";max-age=" + maxAge + prodDomain +";path=/";
        } 
      }
    
      if (ckGetValueFromStrage == ckData) {
        wrapID.classList.add('is-cross-disabled');
        return function(){};
      } else if (!ckGetValueFromStrage){
        closedBtn.addEventListener('click' , (e)=>{
          wrapID.classList.add('is-cross-disabled');
          ckSet(ckValue,ckData,PROD_DOMAIN);
        });
        if (disapearAtFooter === false) {
    
          return function(){
            const doch = window.pageYOffset || document.documentElement.scrollTop; //トップからの現在位置を表示
            const isBodyCls = document.body.classList.contains(bodyActive);
    
            if (doch > offsetTop) {
              wrapID.classList.add(addClass);
            } else if (isBodyCls == false && doch < offsetTop) {
              wrapID.classList.remove(addClass);
            }
          };
    
        } else {
    
          return function(){
            const doch = window.pageYOffset || document.documentElement.scrollTop; //トップからの現在位置を表示
            const relativePositionBottom = document.querySelector(footerCls).getBoundingClientRect().top - window.innerHeight;
            const isBodyCls = document.body.classList.contains(bodyActive);
            if (doch > offsetTop && relativePositionBottom > 0) {
                wrapID.classList.add(addClass);
            } else if(isBodyCls == false && doch < offsetTop) {
                wrapID.classList.remove(addClass);
            } else if(relativePositionBottom < 0) {
                wrapID.classList.remove(addClass);
            }
          };
    
        }
    
      }
    },
    swapAnkr:function(tar,url,cls='',oUrl='',oCls=''){
      const elm = document.querySelector(tar);
      const txt = elm.textContent;
      elm.innerText = '';
      const fragment = document.createDocumentFragment();
      const ankrItem = document.createElement('a');
      ankrItem.href = url;
      ankrItem.className = cls;
      ankrItem.innerText = txt;
      if(oUrl !== ''){
        const ankrItemSecond = document.createElement('a');
        ankrItemSecond.href = oUrl;
        ankrItemSecond.className = oCls;
        ankrItemSecond.innerText = txt;
        fragment.appendChild(ankrItem);
        fragment.appendChild(ankrItemSecond);
        elm.appendChild(fragment);
      } else {
        fragment.appendChild(ankrItem);
        elm.appendChild(fragment);
      };
    }
  }

  window.pretakeScript = pretakeScript;

}

document.addEventListener('DOMContentLoaded', function () {
  

  function omittedContent(string, count = 20) {
    // 定数で宣言
    const MAX_LENGTH = count;
    if (string.length > MAX_LENGTH) {
      return string.substr(0, MAX_LENGTH) + '…';
    }
    return string;
  }

  if (document.body.id === "fs_ProductDetails" || document.body.id === "fs_ProductDetailsSubscribe") {
    let cntDetailQuery = document.querySelectorAll('#cart-fixed__name');

    cntDetailQuery.forEach(content => {
      content.textContent = omittedContent(content.textContent, 40);
    });

  }

  async function aPromise() {
    if (document.querySelectorAll('.fs-c-breadcrumb__list li a')) {
      const limitContentsAncrs = document.querySelectorAll('.fs-c-breadcrumb__list li a');
      limitContentsAncrs.forEach(content => {
        content.textContent = omittedContent(content.textContent);
      });
    }
  }

  async function bPromise() {
    if (document.querySelectorAll('.fs-c-breadcrumb__list li:nth-last-of-type(1)')) {
      await aPromise().then(value => {
        const limitContents = document.querySelectorAll('.fs-c-breadcrumb__list li:nth-last-of-type(1)');
        limitContents.forEach(content => {
          content.textContent = omittedContent(content.textContent);
        });
      });
    }
  }
  bPromise();

});

function getEnvHeight() {
  const height=window.innerHeight;
  document.documentElement.style.setProperty( '--pt-env-vh', height/100 + 'px');
}
getEnvHeight();
window.addEventListener('resize',getEnvHeight ,!document.documentMode ? { passive: true } : false);

window.addEventListener('load', function () {

  const objFitImage1 = document.querySelectorAll('.fs-c-productListItem__imageContainer a img');
  const objFitImage2 = document.querySelectorAll('.fr2-header img');
  const objFitImage3 = document.querySelectorAll('.fs-c-subgroupList__image img');
  const arrays = [objFitImage1,objFitImage2,objFitImage3]
  arrays.forEach(element => {
    objectFitImages(element);
  });
  
});
